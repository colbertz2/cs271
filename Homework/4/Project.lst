Microsoft (R) Macro Assembler Version 14.23.28106.4	    11/27/19 23:36:08
 Arrays and Sorting     (hw4.asm			     Page 1 - 1


				TITLE Arrays and Sorting     (hw4.asm)

				; Author: Zach Colbert
				; CS 271 / Homework 4                 Date: 27 November 2019
				; Description: Creates an array of random integers and sorts it.

				; LIBRARY INCLUDES
				INCLUDE Irvine32.inc
			      C ; Include file for Irvine32.lib             (Irvine32.inc)
			      C 
			      C ;OPTION CASEMAP:NONE		; optional: make identifiers case-sensitive
			      C 
			      C INCLUDE SmallWin.inc		; MS-Windows prototypes, structures, and constants
			      C .NOLIST
			      C .LIST
			      C 
			      C INCLUDE VirtualKeys.inc
			      C ; VirtualKeys.inc
			      C .NOLIST
			      C .LIST
			      C 
			      C 
			      C .NOLIST
			      C .LIST
			      C 
				INCLUDE customMacros.inc
			      C mReadString MACRO buffer, lenBuffer, maxSize
			      C     push EDX
			      C     push ECX
			      C     push EAX
			      C 
			      C     mov EDX, OFFSET buffer
			      C     mov ECX, maxSize
			      C     call ReadString
			      C 
			      C     mov [lenBuffer], EAX
			      C 
			      C     pop EAX
			      C     pop ECX
			      C     pop EDX
			      C ENDM
			      C 
			      C mReadDec MACRO buffer
			      C     push EAX
			      C     pushf
			      C 
			      C     call ReadDec
			      C     mov [buffer], EAX
			      C 
			      C     popf
			      C     pop EAX
			      C ENDM
			      C 
			      C mReadInt MACRO buffer
			      C     push EAX
			      C     pushf
			      C 
			      C     call ReadInt
			      C     mov [buffer], EAX
			      C     
			      C     popf
			      C     pop EAX
			      C ENDM
			      C 
			      C mReadFloat MACRO buffer
			      C     call ReadFloat
			      C     fstp buffer
			      C ENDM
			      C 
			      C mRandomize MACRO
			      C     call Randomize
			      C ENDM
			      C 
			      C mRandomRange MACRO buffer, hi, lo
			      C     push EAX
			      C 
			      C     mov EAX, hi
			      C     sub EAX, lo
			      C     inc EAX
			      C     call RandomRange
			      C     add EAX, lo
			      C     mov [buffer], EAX
			      C 
			      C     pop EAX
			      C ENDM
			      C 
			      C mWriteString MACRO buffer
			      C     push    EDX
			      C     mov     EDX, buffer
			      C     call    WriteString
			      C     pop     EDX
			      C ENDM
			      C 
			      C mWriteDec MACRO num
			      C     push    EAX
			      C     mov     EAX, num
			      C     call    WriteDec
			      C     pop     EAX
			      C ENDM
			      C 
			      C mWriteInt MACRO num
			      C     push    EAX
			      C     mov     EAX, num
			      C     call WriteInt
			      C     pop     EAX
			      C ENDM
			      C 
			      C mWriteFloat MACRO buffer
			      C     fld buffer
			      C     call WriteFloat
			      C     fstp st(0)  ; Throw away the top of the stack
			      C ENDM
			      C 
			      C mNewLine MACRO
			      C     call Crlf
			      C ENDM
			      C 
			      C mCrlf MACRO
			      C     call Crlf
			      C ENDM
			      C 
			      C mClearScreen MACRO
			      C     call ClrScr
			      C ENDM
			      C 
			      C mClrScr MACRO
			      C     call ClrScr
			      C ENDM
			      C 

				; MACRO DEFINITIONS
				; mArrayIndex
				;   Advance ESI to the given DWORD array index.
				mArrayIndex MACRO array, i
				    LOCAL advance
				    LOCAL postloop

				    push ECX
				    pushf

				    mov ESI, array
				    mov ECX, i

				    cmp ECX, 0
				    jz postloop

				    advance:
				        add ESI, sizeof DWORD
				        loop advance

				    postloop:
				    popf
				    pop ECX
				ENDM

				; mArraySwap
				;   Swap two values in an array at indices i and j
				mArraySwap MACRO array, i, j
				    push ESI
				    push EDI
				    pushf

				    mArrayIndex array, i
				    push [ESI]          ; Get value from i
				    mov EDI, ESI        ; Save pointer to this index

				    mArrayIndex array, j
				    push [ESI]          ; Get value from j

				    pop [EDI]           ; Save [j] to i
				    pop [ESI]           ; Save [i] to j

				    popf
				    pop EDI
				    pop ESI
				ENDM

				; CONSTANT DEFINITIONS
 = 0000000A			INPUT_MIN = 10
 = 000000C8			INPUT_MAX = 200
 = 00000064			RAND_MIN = 100
 = 000003E7			RAND_MAX = 999
 = 0000000A			PRINT_PER_LINE = 10
 = 0000001E			HLINE_LENGTH = 30

 00000000			.data
				    ; Intro variables
 00000000 41 72 72 61 79	    progName    BYTE    "Array Sorting Demo", 0
	   20 53 6F 72 74
	   69 6E 67 20 44
	   65 6D 6F 00
 00000013 62 79 20 5A 61	    authName    BYTE    "by Zach Colbert", 0
	   63 68 20 43 6F
	   6C 62 65 72 74
	   00
 00000023  0000001E [		    hline       BYTE    HLINE_LENGTH DUP("-"), 0
	    2D
	   ] 00
 00000042  0000001E [		    dhline      BYTE    HLINE_LENGTH DUP("="), 0
	    3D
	   ] 00

				    ; User input variables
 00000061 45 6E 74 65 72	    prompt1     BYTE    "Enter integer length of array [", 0
	   20 69 6E 74 65
	   67 65 72 20 6C
	   65 6E 67 74 68
	   20 6F 66 20 61
	   72 72 61 79 20
	   5B 00
 00000081 20 2D 20 00		    prompt2     BYTE    " - ", 0
 00000085 5D 3A 20 00		    prompt3     BYTE    "]: ", 0
 00000089 20 69 73 20 74	    tooHi       BYTE    " is too high. Try again.", 0
	   6F 6F 20 68 69
	   67 68 2E 20 54
	   72 79 20 61 67
	   61 69 6E 2E 00
 000000A2 20 69 73 20 74	    tooLo       BYTE    " is too low. Try again.", 0
	   6F 6F 20 6C 6F
	   77 2E 20 54 72
	   79 20 61 67 61
	   69 6E 2E 00
 000000BA 00000000		    arrLength   DWORD   ?

				    ; Unsorted array variables
 000000BE 55 6E 73 6F 72	    unsortHead  BYTE    "Unsorted Array Contents: ", 0
	   74 65 64 20 41
	   72 72 61 79 20
	   43 6F 6E 74 65
	   6E 74 73 3A 20
	   00

				    ; Sorted array variables
 000000D8 53 6F 72 74 65	    sortHead    BYTE    "Sorted Array Contents: ", 0
	   64 20 41 72 72
	   61 79 20 43 6F
	   6E 74 65 6E 74
	   73 3A 20 00
 000000F0 2C 20 00		    delimiter   BYTE    ", ", 0

				    ; Array space in memory
 000000F3  000000C8 [		    list        DWORD   INPUT_MAX DUP(?)    ; Only need WORD b/c max is small?
	    00000000
	   ]

				    ; Array statistics variables
 00000413 00000000		    arrMedian   DWORD   ?
 00000417 00000000		    arrMean     DWORD   ?

 00000000			.code
 00000000			main PROC
 00000000  E8 0000005E		    call intro

 00000005  68 000000BA R	    push OFFSET arrLength
 0000000A  E8 000000A0		    call getUserInput

 0000000F  68 000000F3 R	    push OFFSET list
 00000014  FF 35 000000BA R	    push arrLength
 0000001A  E8 00000143		    call arrayFillRandom

 0000001F  68 000000F3 R	    push OFFSET list
 00000024  FF 35 000000BA R	    push arrLength
 0000002A  68 000000BE R	    push OFFSET unsortHead
 0000002F  E8 00000162		    call arrayPrint

 00000034  68 000000F3 R	    push OFFSET list
 00000039  6A 00		    push 0              ; "Low" index for quicksort
 0000003B  A1 000000BA R	    mov EAX, arrLength
 00000040  48			    dec EAX
 00000041  50			    push EAX            ; "High" index for quicksort
 00000042  E8 000001B0		    call arrayQuickSort

 00000047  68 000000F3 R	    push OFFSET list
 0000004C  FF 35 000000BA R	    push arrLength
 00000052  68 000000D8 R	    push OFFSET sortHead
 00000057  E8 0000013A		    call arrayPrint

				    exit    ; exit to operating system
 0000005C  6A 00	   *	    push   +000000000h
 0000005E  E8 00000000 E   *	    call   ExitProcess
 00000063			main ENDP

				; intro
				;   Prints introductory information about the program.
				;
				;   Receives: 
				;       Global variables progName, authName, dhline
				;   Returns: 
				;       None
				;   Preconditions: 
				;       None
				;   Changes Registers: 
				;       None
 00000063			intro PROC
 00000063  52			    push EDX
				    mWriteString OFFSET dhline
 00000064  52		     1	    push    EDX
 00000065  BA 00000042 R     1	    mov     EDX, OFFSET dhline
 0000006A  E8 00000000 E     1	    call    WriteString
 0000006F  5A		     1	    pop     EDX
				    mNewLine
 00000070  E8 00000000 E     1	    call Crlf
				    mWriteString OFFSET progName
 00000075  52		     1	    push    EDX
 00000076  BA 00000000 R     1	    mov     EDX, OFFSET progName
 0000007B  E8 00000000 E     1	    call    WriteString
 00000080  5A		     1	    pop     EDX
				    mNewLine
 00000081  E8 00000000 E     1	    call Crlf
				    mWriteString OFFSET authName
 00000086  52		     1	    push    EDX
 00000087  BA 00000013 R     1	    mov     EDX, OFFSET authName
 0000008C  E8 00000000 E     1	    call    WriteString
 00000091  5A		     1	    pop     EDX
				    mNewLine
 00000092  E8 00000000 E     1	    call Crlf
				    mWriteString OFFSET dhline
 00000097  52		     1	    push    EDX
 00000098  BA 00000042 R     1	    mov     EDX, OFFSET dhline
 0000009D  E8 00000000 E     1	    call    WriteString
 000000A2  5A		     1	    pop     EDX
				    mNewLine
 000000A3  E8 00000000 E     1	    call Crlf
				    mNewLine
 000000A8  E8 00000000 E     1	    call Crlf
 000000AD  5A			    pop EDX
 000000AE  C3			    ret
 000000AF			intro ENDP

				; getUserInput
				;   Prompts the user for a single, unsigned integer input.
				;   If the input is outside the given range, the user is prompted again.
				;
				;   Receives:
				;       Global byte strings prompt1, prompt2, prompt3, tooHi, tooLo
				;       Global constant DWORDs INPUT_MIN, INPUT_MAX
				;       Reference to DWORD variable in which to store input.
				;   Returns:
				;       DWORD unsigned integer.
				;   Preconditions:
				;       None
				;   Changes Registers:
				;       None
 000000AF			getUserInput PROC    
 000000AF  55			    push EBP
 000000B0  8B EC		    mov EBP, ESP
 000000B2  50			    push EAX
 000000B3  52			    push EDX
 000000B4  56			    push ESI

 000000B5			    prompt:
				        mWriteString OFFSET prompt1
 000000B5  52		     1	    push    EDX
 000000B6  BA 00000061 R     1	    mov     EDX, OFFSET prompt1
 000000BB  E8 00000000 E     1	    call    WriteString
 000000C0  5A		     1	    pop     EDX
				        mWriteDec INPUT_MIN
 000000C1  50		     1	    push    EAX
 000000C2  B8 0000000A	     1	    mov     EAX, INPUT_MIN
 000000C7  E8 00000000 E     1	    call    WriteDec
 000000CC  58		     1	    pop     EAX
				        mWriteString OFFSET prompt2
 000000CD  52		     1	    push    EDX
 000000CE  BA 00000081 R     1	    mov     EDX, OFFSET prompt2
 000000D3  E8 00000000 E     1	    call    WriteString
 000000D8  5A		     1	    pop     EDX
				        mWriteDec INPUT_MAX
 000000D9  50		     1	    push    EAX
 000000DA  B8 000000C8	     1	    mov     EAX, INPUT_MAX
 000000DF  E8 00000000 E     1	    call    WriteDec
 000000E4  58		     1	    pop     EAX
				        mWriteString OFFSET prompt3
 000000E5  52		     1	    push    EDX
 000000E6  BA 00000085 R     1	    mov     EDX, OFFSET prompt3
 000000EB  E8 00000000 E     1	    call    WriteString
 000000F0  5A		     1	    pop     EDX

				    ; Writing to memory and reading from memory again is not optimal
				    ; But it's how the macro works
 000000F1  8B 75 08		    mov ESI, [EBP + 8]
				    mReadDec ESI
 000000F4  50		     1	    push EAX
 000000F5  66| 9C	     1	    pushf
 000000F7  E8 00000000 E     1	    call ReadDec
 000000FC  89 06	     1	    mov [ESI], EAX
 000000FE  66| 9D	     1	    popf
 00000100  58		     1	    pop EAX
 00000101  8B 06		    mov EAX, [ESI]

 00000103  83 F8 0A		    cmp EAX, INPUT_MIN
 00000106  7C 09		    jl boundLo
 00000108  3D 000000C8		    cmp EAX, INPUT_MAX
 0000010D  7F 23		    jg boundHi
 0000010F  EB 45		    jmp fin

 00000111			    boundLo:
				        mWriteDec EAX
 00000111  50		     1	    push    EAX
 00000112  8B C0	     1	    mov     EAX, EAX
 00000114  E8 00000000 E     1	    call    WriteDec
 00000119  58		     1	    pop     EAX
				        mWriteString OFFSET tooLo
 0000011A  52		     1	    push    EDX
 0000011B  BA 000000A2 R     1	    mov     EDX, OFFSET tooLo
 00000120  E8 00000000 E     1	    call    WriteString
 00000125  5A		     1	    pop     EDX
				        mNewLine
 00000126  E8 00000000 E     1	    call Crlf
				        mNewLine
 0000012B  E8 00000000 E     1	    call Crlf
 00000130  EB 83		        jmp prompt

 00000132			    boundHi:
				        mWriteDec EAX
 00000132  50		     1	    push    EAX
 00000133  8B C0	     1	    mov     EAX, EAX
 00000135  E8 00000000 E     1	    call    WriteDec
 0000013A  58		     1	    pop     EAX
				        mWriteString OFFSET tooHi
 0000013B  52		     1	    push    EDX
 0000013C  BA 00000089 R     1	    mov     EDX, OFFSET tooHi
 00000141  E8 00000000 E     1	    call    WriteString
 00000146  5A		     1	    pop     EDX
				        mNewLine
 00000147  E8 00000000 E     1	    call Crlf
				        mNewLine
 0000014C  E8 00000000 E     1	    call Crlf
 00000151  E9 FFFFFF5F		        jmp prompt

 00000156			    fin:
				    mNewLine
 00000156  E8 00000000 E     1	    call Crlf
 0000015B  5E			    pop ESI
 0000015C  5A			    pop EDX
 0000015D  58			    pop EAX
 0000015E  5D			    pop EBP
 0000015F  C2 0004		    ret 4
 00000162			getUserInput ENDP

				; arrayFillRandom
				;   Fills an array with random numbers between RAND_MIN and RAND_MAX
				;
				;   Receives:
				;       Global constants RAND_MIN, RAND_MAX
				;       Pointer to DWORD array, via stack
				;       DWORD size of array, via stack
				;   Returns:
				;       Array filled with random unsigned integer values.
				;   Preconditions:
				;       Array size passed to this proc must be less or equal to
				;       allocated space in memory.
				;   Changes registers:
				;       None
 00000162			arrayFillRandom PROC
 00000162  55			    push EBP
 00000163  8B EC		    mov EBP, ESP
 00000165  51			    push ECX
 00000166  56			    push ESI
 00000167  66| 9C		    pushf

				    mRandomize      ; Set random number seed
 00000169  E8 00000000 E     1	    call Randomize
 0000016E  8B 75 0C		    mov ESI, [EBP + 12]     ; Pointer to first array elem
 00000171  8B 4D 08		    mov ECX, [EBP + 8]      ; ECX = Array size

				    ; Use counted loop to fill array elements
 00000174			    topLoop:
				        ; Save a random number to the current element
				        mRandomRange ESI, RAND_MAX, RAND_MIN
 00000174  50		     1	    push EAX
 00000175  B8 000003E7	     1	    mov EAX, RAND_MAX
 0000017A  83 E8 64	     1	    sub EAX, RAND_MIN
 0000017D  40		     1	    inc EAX
 0000017E  E8 00000000 E     1	    call RandomRange
 00000183  83 C0 64	     1	    add EAX, RAND_MIN
 00000186  89 06	     1	    mov [ESI], EAX
 00000188  58		     1	    pop EAX
 00000189  83 C6 04		        add ESI, sizeof DWORD   ; Advance to next element
 0000018C  E2 E6		        loop topLoop    ; Loop again if ECX != 0

 0000018E			    postLoop:
 0000018E  66| 9D		    popf
 00000190  5E			    pop ESI
 00000191  59			    pop ECX
 00000192  5D			    pop EBP
 00000193  C2 0008		    ret 8
 00000196			arrayFillRandom ENDP

				; arrayPrint
				;   Prints the contents of an array of unsigned ints.
				;
				;   Receives:
				;       Global constants, PRINT_PER_LINE and DELIMITER
				;       Pointer to DWORD array, via stack (reference).
				;       DWORD size of array, via stack (value).
				;       Pointer to BYTE string, via stack.
				;           (Prints additional info before array elements).
				;   Returns:
				;       Array contents printed to console, max PRINT_PER_LINE
				;       elements per line and delimited by string DELIMITER.
				;   Preconditions:
				;       None
				;   Changes Registers:
				;       None
 00000196			arrayPrint PROC
 00000196  55			    push EBP
 00000197  8B EC		    mov EBP, ESP
 00000199  50			    push EAX
 0000019A  51			    push ECX
 0000019B  56			    push ESI
 0000019C  66| 9C		    pushf

 0000019E  8B 75 08		    mov ESI, [EBP + 8]      ; Pointer to info string
				    mWriteString ESI
 000001A1  52		     1	    push    EDX
 000001A2  8B D6	     1	    mov     EDX, ESI
 000001A4  E8 00000000 E     1	    call    WriteString
 000001A9  5A		     1	    pop     EDX
				    mNewLine
 000001AA  E8 00000000 E     1	    call Crlf

 000001AF  8B 75 10		    mov ESI, [EBP + 16]     ; Pointer to first array elem
 000001B2  8B 4D 0C		    mov ECX, [EBP + 12]     ; ECX = array size
 000001B5  B8 00000000		    mov EAX, 0              ; Init EAX = 0

 000001BA			    topLoop:
				        mWriteDec [ESI]         ; Write element to console
 000001BA  50		     1	    push    EAX
 000001BB  8B 06	     1	    mov     EAX, [ESI]
 000001BD  E8 00000000 E     1	    call    WriteDec
 000001C2  58		     1	    pop     EAX
 000001C3  83 C6 04		        add ESI, sizeof DWORD   ; Advance to next element
 000001C6  40			        inc EAX                 ; EAX += 1
				        
 000001C7  83 F9 01		        cmp ECX, 1
 000001CA  74 16		        je continue             ; Follow each element with a delimiter
				        mWriteString OFFSET DELIMITER  ; Except after last element
 000001CC  52		     1	    push    EDX
 000001CD  BA 000000F0 R     1	    mov     EDX, OFFSET DELIMITER
 000001D2  E8 00000000 E     1	    call    WriteString
 000001D7  5A		     1	    pop     EDX
				        
 000001D8  83 F8 0A		        cmp EAX, PRINT_PER_LINE
 000001DB  75 05		        jne continue            ; Insert newline every few elements
				        mNewLine
 000001DD  E8 00000000 E     1	    call Crlf

 000001E2			        continue:
 000001E2  E2 D6		            loop topLoop

				    mNewLine
 000001E4  E8 00000000 E     1	    call Crlf
				    mNewLine
 000001E9  E8 00000000 E     1	    call Crlf

 000001EE  66| 9D		    popf
 000001F0  5E			    pop ESI
 000001F1  59			    pop ECX
 000001F2  58			    pop EAX
 000001F3  5D			    pop EBP
 000001F4  C2 000C		    ret 12
 000001F7			arrayPrint ENDP

				; arrayQuickSort
				;   Uses the Quicksort algorithm to sort the given array in place.
				;   Based on info and algorithms from https://www.geeksforgeeks.org/quick-sort/
				;
				;   Receives:
				;       Pointer to DWORD array, via stack (reference).
				;       DWORD starting index, via stack (value). Initially call with 0.
				;       DWORD ending index, via stack (value). Initially call with max index.
				;   Returns:
				;       Sorted array in memory.
				;   Preconditions:
				;       None.
				;   Registers Changed:
				;       None.
 000001F7			arrayQuickSort PROC
 000001F7  55			    push EBP
 000001F8  8B EC		    mov EBP, ESP
 000001FA  50			    push EAX
 000001FB  53			    push EBX
 000001FC  66| 9C		    pushf

 000001FE  8B 45 0C		    mov EAX, [EBP + 12]     ; EAX = Starting index (lo)
 00000201  3B 45 08		    cmp EAX, [EBP + 8]      ; Compare lo to ending index (hi)
 00000204  7D 21		    jge postcon             ; if (lo < hi) { ... } else { return; }

 00000206  E8 00000039		    call qsPartition        ; EAX = partition index (pi)
 0000020B  8B D8		    mov EBX, EAX
 0000020D  48			    dec EAX         ; EAX = pi - 1
 0000020E  43			    inc EBX         ; EBX = pi + 1

 0000020F  FF 75 10		    push [EBP + 16]         ; Array pointer
 00000212  FF 75 0C		    push [EBP + 12]         ; Same lo value
 00000215  50			    push EAX                ; Pass pi - 1 as hi
 00000216  E8 FFFFFFDC		    call arrayQuickSort     ; Sort the parts of the array up to pi

 0000021B  FF 75 10		    push [EBP + 16]         ; Array pointer
 0000021E  53			    push EBX                ; Pass pi + 1 as lo
 0000021F  FF 75 08		    push [EBP + 8]          ; Same hi value
 00000222  E8 FFFFFFD0		    call arrayQuickSort     ; Sort the parts of the array after pi

 00000227			    postcon:
				    ; FOR DEBUG
 00000227  68 000000F3 R	    push OFFSET list
 0000022C  FF 35 000000BA R	    push arrLength
 00000232  68 000000F0 R	    push OFFSET delimiter
 00000237  E8 FFFFFF5A		    call arrayPrint

 0000023C  66| 9D		    popf
 0000023E  5B			    pop EBX
 0000023F  58			    pop EAX
 00000240  5D			    pop EBP
 00000241  C2 000C		    ret 12
 00000244			arrayQuickSort ENDP

				; qsPartition
 00000244			qsPartition PROC    ; +16 array, +12 lo, +8 hi
				    ;push EBP
				    ;mov EBP, ESP        Keep using the same stack frame!
 00000244  56			    push ESI
 00000245  53			    push EBX
 00000246  51			    push ECX
 00000247  57			    push EDI
 00000248  66| 9C		    pushf

				    mArrayIndex [EBP + 16], [EBP + 8]   ; ESI = (array + hi)
 0000024A  51		     1	    push ECX
 0000024B  66| 9C	     1	    pushf
 0000024D  8B 75 10	     1	    mov ESI, [EBP + 16]
 00000250  8B 4D 08	     1	    mov ECX, [EBP + 8]
 00000253  83 F9 00	     1	    cmp ECX, 0
 00000256  74 05	     1	    jz ??0001
 00000258		     1	    ??0000:
 00000258  83 C6 04	     1	        add ESI, sizeof DWORD
 0000025B  E2 FB	     1	        loop ??0000
 0000025D		     1	    ??0001:
 0000025D  66| 9D	     1	    popf
 0000025F  59		     1	    pop ECX
 00000260  8B 06		    mov EAX, [ESI]      ; Save pivot value to EAX

 00000262  8B 5D 0C		    mov EBX, [EBP + 12]
 00000265  4B			    dec EBX             ; EBX = lo - 1
				    mArrayIndex [EBP + 16], [EBP + 12]      ; ESI (array + lo)
 00000266  51		     1	    push ECX
 00000267  66| 9C	     1	    pushf
 00000269  8B 75 10	     1	    mov ESI, [EBP + 16]
 0000026C  8B 4D 0C	     1	    mov ECX, [EBP + 12]
 0000026F  83 F9 00	     1	    cmp ECX, 0
 00000272  74 05	     1	    jz ??0003
 00000274		     1	    ??0002:
 00000274  83 C6 04	     1	        add ESI, sizeof DWORD
 00000277  E2 FB	     1	        loop ??0002
 00000279		     1	    ??0003:
 00000279  66| 9D	     1	    popf
 0000027B  59		     1	    pop ECX
 0000027C  8B 4D 0C		    mov ECX, [EBP + 12]     ; Loop counter = lo

 0000027F			    sortLoop:
 0000027F  8B 3E		        mov EDI, [ESI]
 00000281  3B F8		        cmp EDI, EAX        ; Compare current value to pivot value
 00000283  7D 46		        jge postLoop
 00000285  43			        inc EBX         ; If current value < pivot
				        mArraySwap [EBP + 16], EBX, ECX
 00000286  56		     1	    push ESI
 00000287  57		     1	    push EDI
 00000288  66| 9C	     1	    pushf
 0000028A  51		     2	    push ECX
 0000028B  66| 9C	     2	    pushf
 0000028D  8B 75 10	     2	    mov ESI, [EBP + 16]
 00000290  8B CB	     2	    mov ECX, EBX
 00000292  83 F9 00	     2	    cmp ECX, 0
 00000295  74 05	     2	    jz ??0005
 00000297		     2	    ??0004:
 00000297  83 C6 04	     2	        add ESI, sizeof DWORD
 0000029A  E2 FB	     2	        loop ??0004
 0000029C		     2	    ??0005:
 0000029C  66| 9D	     2	    popf
 0000029E  59		     2	    pop ECX
 0000029F  FF 36	     1	    push [ESI]          ; Get value from i
 000002A1  8B FE	     1	    mov EDI, ESI        ; Save pointer to this index
 000002A3  51		     2	    push ECX
 000002A4  66| 9C	     2	    pushf
 000002A6  8B 75 10	     2	    mov ESI, [EBP + 16]
 000002A9  8B C9	     2	    mov ECX, ECX
 000002AB  83 F9 00	     2	    cmp ECX, 0
 000002AE  74 05	     2	    jz ??0007
 000002B0		     2	    ??0006:
 000002B0  83 C6 04	     2	        add ESI, sizeof DWORD
 000002B3  E2 FB	     2	        loop ??0006
 000002B5		     2	    ??0007:
 000002B5  66| 9D	     2	    popf
 000002B7  59		     2	    pop ECX
 000002B8  FF 36	     1	    push [ESI]          ; Get value from j
 000002BA  8F 07	     1	    pop [EDI]           ; Save [j] to i
 000002BC  8F 06	     1	    pop [ESI]           ; Save [i] to j
 000002BE  66| 9D	     1	    popf
 000002C0  5F		     1	    pop EDI
 000002C1  5E		     1	    pop ESI
 000002C2  83 C6 04		        add ESI, sizeof DWORD   ; Advance to next element
 000002C5  41			        inc ECX                 ; Advance to next element
 000002C6  3B 4D 08		        cmp ECX, [EBP + 8]
 000002C9  7C B4		        jl sortLoop

 000002CB			    postLoop:
 000002CB  43			        inc EBX             ; EBX = i + 1
				        mArraySwap [EBP + 16], EBX, [EBP + 8]   ; Swap [i+1] and [hi]
 000002CC  56		     1	    push ESI
 000002CD  57		     1	    push EDI
 000002CE  66| 9C	     1	    pushf
 000002D0  51		     2	    push ECX
 000002D1  66| 9C	     2	    pushf
 000002D3  8B 75 10	     2	    mov ESI, [EBP + 16]
 000002D6  8B CB	     2	    mov ECX, EBX
 000002D8  83 F9 00	     2	    cmp ECX, 0
 000002DB  74 05	     2	    jz ??0009
 000002DD		     2	    ??0008:
 000002DD  83 C6 04	     2	        add ESI, sizeof DWORD
 000002E0  E2 FB	     2	        loop ??0008
 000002E2		     2	    ??0009:
 000002E2  66| 9D	     2	    popf
 000002E4  59		     2	    pop ECX
 000002E5  FF 36	     1	    push [ESI]          ; Get value from i
 000002E7  8B FE	     1	    mov EDI, ESI        ; Save pointer to this index
 000002E9  51		     2	    push ECX
 000002EA  66| 9C	     2	    pushf
 000002EC  8B 75 10	     2	    mov ESI, [EBP + 16]
 000002EF  8B 4D 08	     2	    mov ECX, [EBP + 8]
 000002F2  83 F9 00	     2	    cmp ECX, 0
 000002F5  74 05	     2	    jz ??000B
 000002F7		     2	    ??000A:
 000002F7  83 C6 04	     2	        add ESI, sizeof DWORD
 000002FA  E2 FB	     2	        loop ??000A
 000002FC		     2	    ??000B:
 000002FC  66| 9D	     2	    popf
 000002FE  59		     2	    pop ECX
 000002FF  FF 36	     1	    push [ESI]          ; Get value from j
 00000301  8F 07	     1	    pop [EDI]           ; Save [j] to i
 00000303  8F 06	     1	    pop [ESI]           ; Save [i] to j
 00000305  66| 9D	     1	    popf
 00000307  5F		     1	    pop EDI
 00000308  5E		     1	    pop ESI
 00000309  8B C3		        mov EAX, EBX        ; return i + 1

 0000030B  66| 9D		    popf
 0000030D  5F			    pop EDI
 0000030E  59			    pop ECX
 0000030F  5B			    pop EBX
 00000310  5E			    pop ESI
				    ;pop EBP
 00000311  C3			    ret
 00000312			qsPartition ENDP

				END main
Microsoft (R) Macro Assembler Version 14.23.28106.4	    11/27/19 23:36:08
 Arrays and Sorting     (hw4.asm			     Symbols 2 - 1




Macros:

                N a m e                 Type

mArrayIndex  . . . . . . . . . .	Proc
mArraySwap . . . . . . . . . . .	Proc
mClearScreen . . . . . . . . . .	Proc
mClrScr  . . . . . . . . . . . .	Proc
mCrlf  . . . . . . . . . . . . .	Proc
mNewLine . . . . . . . . . . . .	Proc
mRandomRange . . . . . . . . . .	Proc
mRandomize . . . . . . . . . . .	Proc
mReadDec . . . . . . . . . . . .	Proc
mReadFloat . . . . . . . . . . .	Proc
mReadInt . . . . . . . . . . . .	Proc
mReadString  . . . . . . . . . .	Proc
mWriteDec  . . . . . . . . . . .	Proc
mWriteFloat  . . . . . . . . . .	Proc
mWriteInt  . . . . . . . . . . .	Proc
mWriteString . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

CONSOLE_CURSOR_INFO  . . . . . .	 00000008
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  bVisible . . . . . . . . . . .	 00000004	 DWord
CONSOLE_SCREEN_BUFFER_INFO . . .	 00000016
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCursorPosition . . . . . . .	 00000004	 DWord
  wAttributes  . . . . . . . . .	 00000008	 Word
  srWindow . . . . . . . . . . .	 0000000A	 QWord
  dwMaximumWindowSize  . . . . .	 00000012	 DWord
COORD  . . . . . . . . . . . . .	 00000004
  X  . . . . . . . . . . . . . .	 00000000	 Word
  Y  . . . . . . . . . . . . . .	 00000002	 Word
FILETIME . . . . . . . . . . . .	 00000008
  loDateTime . . . . . . . . . .	 00000000	 DWord
  hiDateTime . . . . . . . . . .	 00000004	 DWord
FOCUS_EVENT_RECORD . . . . . . .	 00000004
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
FPU_ENVIRON  . . . . . . . . . .	 0000001C
  controlWord  . . . . . . . . .	 00000000	 Word
  statusWord . . . . . . . . . .	 00000004	 Word
  tagWord  . . . . . . . . . . .	 00000008	 Word
  instrPointerOffset . . . . . .	 0000000C	 DWord
  instrPointerSelector . . . . .	 00000010	 DWord
  operandPointerOffset . . . . .	 00000014	 DWord
  operandPointerSelector . . . .	 00000018	 Word
INPUT_RECORD . . . . . . . . . .	 00000014
  EventType  . . . . . . . . . .	 00000000	 Word
  Event  . . . . . . . . . . . .	 00000004	 XmmWord
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCommandId  . . . . . . . . .	 00000000	 DWord
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
KEY_EVENT_RECORD . . . . . . . .	 00000010
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
MENU_EVENT_RECORD  . . . . . . .	 00000004
  dwCommandId  . . . . . . . . .	 00000000	 DWord
MOUSE_EVENT_RECORD . . . . . . .	 00000010
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
SMALL_RECT . . . . . . . . . . .	 00000008
  Left . . . . . . . . . . . . .	 00000000	 Word
  Top  . . . . . . . . . . . . .	 00000002	 Word
  Right  . . . . . . . . . . . .	 00000004	 Word
  Bottom . . . . . . . . . . . .	 00000006	 Word
SYSTEMTIME . . . . . . . . . . .	 00000010
  wYear  . . . . . . . . . . . .	 00000000	 Word
  wMonth . . . . . . . . . . . .	 00000002	 Word
  wDayOfWeek . . . . . . . . . .	 00000004	 Word
  wDay . . . . . . . . . . . . .	 00000006	 Word
  wHour  . . . . . . . . . . . .	 00000008	 Word
  wMinute  . . . . . . . . . . .	 0000000A	 Word
  wSecond  . . . . . . . . . . .	 0000000C	 Word
  wMilliseconds  . . . . . . . .	 0000000E	 Word
WINDOW_BUFFER_SIZE_RECORD  . . .	 00000004
  dwSize . . . . . . . . . . . .	 00000000	 DWord


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 Para	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 0000041B Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00000312 Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

CloseFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CloseHandle  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Clrscr . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFileA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateOutputFile . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Crlf . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Delay  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpMem  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpRegs . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToDosDateTime  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToSystemTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlushConsoleInputBuffer  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FormatMessageA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandLineA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandTail . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCP . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleScreenBufferInfo . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDateTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyState  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLastError . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMaxXY . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMseconds  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberOfConsoleInputEvents  .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessHeap . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStdHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTime  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTickCount . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Gotoxy . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapAlloc  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapCreate . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapDestroy  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapFree . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapSize . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsDigit  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalFree  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MessageBoxA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBoxAsk  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBox . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenInputFile  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseDecimal32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseInteger32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Random32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RandomRange  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Randomize  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadChar . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadDec  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFloat  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFromFile . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadHex  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadInt  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKeyFlush . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKey  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadString . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorPosition . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleScreenBufferSize . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTextAttribute  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTitleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleWindowInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFilePointer . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ShowFPUStack . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Sleep  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StrLength  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_compare  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_copy . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_length . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_trim . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_ucase  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SystemTimeToFileTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitMsg  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBinB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBin . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteChar  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputAttribute  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputCharacterA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteDec . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFloat . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHexB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHex . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteInt . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrameName  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrame  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteString  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteToFile  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteWindowsMsg  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arrayFillRandom  . . . . . . . .	P Near	 00000162 _TEXT	Length= 00000034 Public STDCALL
  topLoop  . . . . . . . . . . .	L Near	 00000174 _TEXT	
  postLoop . . . . . . . . . . .	L Near	 0000018E _TEXT	
arrayPrint . . . . . . . . . . .	P Near	 00000196 _TEXT	Length= 00000061 Public STDCALL
  topLoop  . . . . . . . . . . .	L Near	 000001BA _TEXT	
  continue . . . . . . . . . . .	L Near	 000001E2 _TEXT	
arrayQuickSort . . . . . . . . .	P Near	 000001F7 _TEXT	Length= 0000004D Public STDCALL
  postcon  . . . . . . . . . . .	L Near	 00000227 _TEXT	
getUserInput . . . . . . . . . .	P Near	 000000AF _TEXT	Length= 000000B3 Public STDCALL
  prompt . . . . . . . . . . . .	L Near	 000000B5 _TEXT	
  boundLo  . . . . . . . . . . .	L Near	 00000111 _TEXT	
  boundHi  . . . . . . . . . . .	L Near	 00000132 _TEXT	
  fin  . . . . . . . . . . . . .	L Near	 00000156 _TEXT	
intro  . . . . . . . . . . . . .	P Near	 00000063 _TEXT	Length= 0000004C Public STDCALL
main . . . . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 00000063 Public STDCALL
printf . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
qsPartition  . . . . . . . . . .	P Near	 00000244 _TEXT	Length= 000000CE Public STDCALL
  ??0000 . . . . . . . . . . . .	L Near	 00000258 _TEXT	
  ??0001 . . . . . . . . . . . .	L Near	 0000025D _TEXT	
  ??0002 . . . . . . . . . . . .	L Near	 00000274 _TEXT	
  ??0003 . . . . . . . . . . . .	L Near	 00000279 _TEXT	
  sortLoop . . . . . . . . . . .	L Near	 0000027F _TEXT	
  ??0004 . . . . . . . . . . . .	L Near	 00000297 _TEXT	
  ??0005 . . . . . . . . . . . .	L Near	 0000029C _TEXT	
  ??0006 . . . . . . . . . . . .	L Near	 000002B0 _TEXT	
  ??0007 . . . . . . . . . . . .	L Near	 000002B5 _TEXT	
  postLoop . . . . . . . . . . .	L Near	 000002CB _TEXT	
  ??0008 . . . . . . . . . . . .	L Near	 000002DD _TEXT	
  ??0009 . . . . . . . . . . . .	L Near	 000002E2 _TEXT	
  ??000A . . . . . . . . . . . .	L Near	 000002F7 _TEXT	
  ??000B . . . . . . . . . . . .	L Near	 000002FC _TEXT	
scanf  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
wsprintfA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
ALT_MASK . . . . . . . . . . . .	Number	 00000003h   
CAPSLOCK_ON  . . . . . . . . . .	Number	 00000080h   
CREATE_ALWAYS  . . . . . . . . .	Number	 00000002h   
CREATE_NEW . . . . . . . . . . .	Number	 00000001h   
CTRL_MASK  . . . . . . . . . . .	Number	 0000000Ch   
CreateFile . . . . . . . . . . .	Text   	 CreateFileA
DO_NOT_SHARE . . . . . . . . . .	Number	 00000000h   
ENABLE_ECHO_INPUT  . . . . . . .	Number	 00000004h   
ENABLE_LINE_INPUT  . . . . . . .	Number	 00000002h   
ENABLE_MOUSE_INPUT . . . . . . .	Number	 00000010h   
ENABLE_PROCESSED_INPUT . . . . .	Number	 00000001h   
ENABLE_PROCESSED_OUTPUT  . . . .	Number	 00000001h   
ENABLE_WINDOW_INPUT  . . . . . .	Number	 00000008h   
ENABLE_WRAP_AT_EOL_OUTPUT  . . .	Number	 00000002h   
ENHANCED_KEY . . . . . . . . . .	Number	 00000100h   
FALSE  . . . . . . . . . . . . .	Number	 00000000h   
FILE_APPEND_DATA . . . . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_ARCHIVE . . . . .	Number	 00000020h   
FILE_ATTRIBUTE_COMPRESSED  . . .	Number	 00000800h   
FILE_ATTRIBUTE_DEVICE  . . . . .	Number	 00000040h   
FILE_ATTRIBUTE_DIRECTORY . . . .	Number	 00000010h   
FILE_ATTRIBUTE_ENCRYPTED . . . .	Number	 00004000h   
FILE_ATTRIBUTE_HIDDEN  . . . . .	Number	 00000002h   
FILE_ATTRIBUTE_NORMAL  . . . . .	Number	 00000080h   
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED .	Number	 00002000h   
FILE_ATTRIBUTE_OFFLINE . . . . .	Number	 00001000h   
FILE_ATTRIBUTE_READONLY  . . . .	Number	 00000001h   
FILE_ATTRIBUTE_REPARSE_POINT . .	Number	 00000400h   
FILE_ATTRIBUTE_SPARSE_FILE . . .	Number	 00000200h   
FILE_ATTRIBUTE_SYSTEM  . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_TEMPORARY . . . .	Number	 00000100h   
FILE_BEGIN . . . . . . . . . . .	Number	 00000000h   
FILE_CURRENT . . . . . . . . . .	Number	 00000001h   
FILE_DELETE_CHILD  . . . . . . .	Number	 00000040h   
FILE_END . . . . . . . . . . . .	Number	 00000002h   
FILE_READ_DATA . . . . . . . . .	Number	 00000001h   
FILE_SHARE_DELETE  . . . . . . .	Number	 00000004h   
FILE_SHARE_READ  . . . . . . . .	Number	 00000001h   
FILE_SHARE_WRITE . . . . . . . .	Number	 00000002h   
FILE_WRITE_DATA  . . . . . . . .	Number	 00000002h   
FOCUS_EVENT  . . . . . . . . . .	Number	 00000010h   
FORMAT_MESSAGE_ALLOCATE_BUFFER .	Number	 00000100h   
FORMAT_MESSAGE_FROM_SYSTEM . . .	Number	 00001000h   
FormatMessage  . . . . . . . . .	Text   	 FormatMessageA
GENERIC_ALL  . . . . . . . . . .	Number	 10000000h   
GENERIC_EXECUTE  . . . . . . . .	Number	 20000000h   
GENERIC_READ . . . . . . . . . .	Number	 -80000000h   
GENERIC_WRITE  . . . . . . . . .	Number	 40000000h   
GetCommandLine . . . . . . . . .	Text   	 GetCommandLineA
HANDLE . . . . . . . . . . . . .	Text   	 DWORD
HEAP_GENERATE_EXCEPTIONS . . . .	Number	 00000004h   
HEAP_GROWABLE  . . . . . . . . .	Number	 00000002h   
HEAP_NO_SERIALIZE  . . . . . . .	Number	 00000001h   
HEAP_REALLOC_IN_PLACE_ONLY . . .	Number	 00000010h   
HEAP_ZERO_MEMORY . . . . . . . .	Number	 00000008h   
HLINE_LENGTH . . . . . . . . . .	Number	 0000001Eh   
IDABORT  . . . . . . . . . . . .	Number	 00000003h   
IDCANCEL . . . . . . . . . . . .	Number	 00000002h   
IDCLOSE  . . . . . . . . . . . .	Number	 00000008h   
IDCONTINUE . . . . . . . . . . .	Number	 0000000Bh   
IDHELP . . . . . . . . . . . . .	Number	 00000009h   
IDIGNORE . . . . . . . . . . . .	Number	 00000005h   
IDNO . . . . . . . . . . . . . .	Number	 00000007h   
IDOK . . . . . . . . . . . . . .	Number	 00000001h   
IDRETRY  . . . . . . . . . . . .	Number	 00000004h   
IDTIMEOUT  . . . . . . . . . . .	Number	 00007D00h   
IDTRYAGAIN . . . . . . . . . . .	Number	 0000000Ah   
IDYES  . . . . . . . . . . . . .	Number	 00000006h   
INPUT_MAX  . . . . . . . . . . .	Number	 000000C8h   
INPUT_MIN  . . . . . . . . . . .	Number	 0000000Ah   
INVALID_HANDLE_VALUE . . . . . .	Number	 -00000001h   
KBDOWN_FLAG  . . . . . . . . . .	Number	 00000001h   
KEY_EVENT  . . . . . . . . . . .	Number	 00000001h   
KEY_MASKS  . . . . . . . . . . .	Number	 0000001Fh   
LEFT_ALT_PRESSED . . . . . . . .	Number	 00000002h   
LEFT_CTRL_PRESSED  . . . . . . .	Number	 00000008h   
MB_ABORTRETRYIGNORE  . . . . . .	Number	 00000002h   
MB_APPLMODAL . . . . . . . . . .	Number	 00000000h   
MB_CANCELTRYCONTINUE . . . . . .	Number	 00000006h   
MB_DEFBUTTON1  . . . . . . . . .	Number	 00000000h   
MB_DEFBUTTON2  . . . . . . . . .	Number	 00000100h   
MB_DEFBUTTON3  . . . . . . . . .	Number	 00000200h   
MB_DEFBUTTON4  . . . . . . . . .	Number	 00000300h   
MB_HELP  . . . . . . . . . . . .	Number	 00004000h   
MB_ICONASTERISK  . . . . . . . .	Number	 00000040h   
MB_ICONERROR . . . . . . . . . .	Number	 00000010h   
MB_ICONEXCLAMATION . . . . . . .	Number	 00000030h   
MB_ICONHAND  . . . . . . . . . .	Number	 00000010h   
MB_ICONINFORMATION . . . . . . .	Number	 00000040h   
MB_ICONQUESTION  . . . . . . . .	Number	 00000020h   
MB_ICONSTOP  . . . . . . . . . .	Number	 00000010h   
MB_ICONWARNING . . . . . . . . .	Number	 00000030h   
MB_OKCANCEL  . . . . . . . . . .	Number	 00000001h   
MB_OK  . . . . . . . . . . . . .	Number	 00000000h   
MB_RETRYCANCEL . . . . . . . . .	Number	 00000005h   
MB_SYSTEMMODAL . . . . . . . . .	Number	 00001000h   
MB_TASKMODAL . . . . . . . . . .	Number	 00002000h   
MB_USERICON  . . . . . . . . . .	Number	 00000080h   
MB_YESNOCANCEL . . . . . . . . .	Number	 00000003h   
MB_YESNO . . . . . . . . . . . .	Number	 00000004h   
MENU_EVENT . . . . . . . . . . .	Number	 00000008h   
MOUSE_EVENT  . . . . . . . . . .	Number	 00000002h   
MessageBox . . . . . . . . . . .	Text   	 MessageBoxA
NULL . . . . . . . . . . . . . .	Number	 00000000h   
NUMLOCK_ON . . . . . . . . . . .	Number	 00000020h   
OPEN_ALWAYS  . . . . . . . . . .	Number	 00000004h   
OPEN_EXISTING  . . . . . . . . .	Number	 00000003h   
PRINT_PER_LINE . . . . . . . . .	Number	 0000000Ah   
PeekConsoleInput . . . . . . . .	Text   	 PeekConsoleInputA
RAND_MAX . . . . . . . . . . . .	Number	 000003E7h   
RAND_MIN . . . . . . . . . . . .	Number	 00000064h   
RIGHT_ALT_PRESSED  . . . . . . .	Number	 00000001h   
RIGHT_CTRL_PRESSED . . . . . . .	Number	 00000004h   
ReadConsoleInput . . . . . . . .	Text   	 ReadConsoleInputA
ReadConsole  . . . . . . . . . .	Text   	 ReadConsoleA
SCROLLLOCK_ON  . . . . . . . . .	Number	 00000040h   
SHIFT_MASK . . . . . . . . . . .	Number	 00000010h   
SHIFT_PRESSED  . . . . . . . . .	Number	 00000010h   
STD_ERROR_HANDLE . . . . . . . .	Number	 -0000000Ch   
STD_INPUT_HANDLE . . . . . . . .	Number	 -0000000Ah   
STD_OUTPUT_HANDLE  . . . . . . .	Number	 -0000000Bh   
SetConsoleTitle  . . . . . . . .	Text   	 SetConsoleTitleA
TAB  . . . . . . . . . . . . . .	Number	 00000009h   
TRUE . . . . . . . . . . . . . .	Number	 00000001h   
TRUNCATE_EXISTING  . . . . . . .	Number	 00000005h   
VK_11  . . . . . . . . . . . . .	Number	 000000BDh   
VK_12  . . . . . . . . . . . . .	Number	 000000BBh   
VK_ADD . . . . . . . . . . . . .	Number	 0000006Bh   
VK_BACK  . . . . . . . . . . . .	Number	 00000008h   
VK_CANCEL  . . . . . . . . . . .	Number	 00000003h   
VK_CAPITAL . . . . . . . . . . .	Number	 00000014h   
VK_CLEAR . . . . . . . . . . . .	Number	 0000000Ch   
VK_CONTROL . . . . . . . . . . .	Number	 00000011h   
VK_DECIMAL . . . . . . . . . . .	Number	 0000006Eh   
VK_DELETE  . . . . . . . . . . .	Number	 0000002Eh   
VK_DIVIDE  . . . . . . . . . . .	Number	 0000006Fh   
VK_DOWN  . . . . . . . . . . . .	Number	 00000028h   
VK_END . . . . . . . . . . . . .	Number	 00000023h   
VK_ESCAPE  . . . . . . . . . . .	Number	 0000001Bh   
VK_EXECUTE . . . . . . . . . . .	Number	 0000002Bh   
VK_F10 . . . . . . . . . . . . .	Number	 00000079h   
VK_F11 . . . . . . . . . . . . .	Number	 0000007Ah   
VK_F12 . . . . . . . . . . . . .	Number	 0000007Bh   
VK_F13 . . . . . . . . . . . . .	Number	 0000007Ch   
VK_F14 . . . . . . . . . . . . .	Number	 0000007Dh   
VK_F15 . . . . . . . . . . . . .	Number	 0000007Eh   
VK_F16 . . . . . . . . . . . . .	Number	 0000007Fh   
VK_F17 . . . . . . . . . . . . .	Number	 00000080h   
VK_F18 . . . . . . . . . . . . .	Number	 00000081h   
VK_F19 . . . . . . . . . . . . .	Number	 00000082h   
VK_F1  . . . . . . . . . . . . .	Number	 00000070h   
VK_F20 . . . . . . . . . . . . .	Number	 00000083h   
VK_F21 . . . . . . . . . . . . .	Number	 00000084h   
VK_F22 . . . . . . . . . . . . .	Number	 00000085h   
VK_F23 . . . . . . . . . . . . .	Number	 00000086h   
VK_F24 . . . . . . . . . . . . .	Number	 00000087h   
VK_F2  . . . . . . . . . . . . .	Number	 00000071h   
VK_F3  . . . . . . . . . . . . .	Number	 00000072h   
VK_F4  . . . . . . . . . . . . .	Number	 00000073h   
VK_F5  . . . . . . . . . . . . .	Number	 00000074h   
VK_F6  . . . . . . . . . . . . .	Number	 00000075h   
VK_F7  . . . . . . . . . . . . .	Number	 00000076h   
VK_F8  . . . . . . . . . . . . .	Number	 00000077h   
VK_F9  . . . . . . . . . . . . .	Number	 00000078h   
VK_HELP  . . . . . . . . . . . .	Number	 0000002Fh   
VK_HOME  . . . . . . . . . . . .	Number	 00000024h   
VK_INSERT  . . . . . . . . . . .	Number	 0000002Dh   
VK_LBUTTON . . . . . . . . . . .	Number	 00000001h   
VK_LCONTROL  . . . . . . . . . .	Number	 000000A2h   
VK_LEFT  . . . . . . . . . . . .	Number	 00000025h   
VK_LMENU . . . . . . . . . . . .	Number	 000000A4h   
VK_LSHIFT  . . . . . . . . . . .	Number	 000000A0h   
VK_MENU  . . . . . . . . . . . .	Number	 00000012h   
VK_MULTIPLY  . . . . . . . . . .	Number	 0000006Ah   
VK_NEXT  . . . . . . . . . . . .	Number	 00000022h   
VK_NUMLOCK . . . . . . . . . . .	Number	 00000090h   
VK_NUMPAD0 . . . . . . . . . . .	Number	 00000060h   
VK_NUMPAD1 . . . . . . . . . . .	Number	 00000061h   
VK_NUMPAD2 . . . . . . . . . . .	Number	 00000062h   
VK_NUMPAD3 . . . . . . . . . . .	Number	 00000063h   
VK_NUMPAD4 . . . . . . . . . . .	Number	 00000064h   
VK_NUMPAD5 . . . . . . . . . . .	Number	 00000065h   
VK_NUMPAD6 . . . . . . . . . . .	Number	 00000066h   
VK_NUMPAD7 . . . . . . . . . . .	Number	 00000067h   
VK_NUMPAD8 . . . . . . . . . . .	Number	 00000068h   
VK_NUMPAD9 . . . . . . . . . . .	Number	 00000069h   
VK_PAUSE . . . . . . . . . . . .	Number	 00000013h   
VK_PRINT . . . . . . . . . . . .	Number	 0000002Ah   
VK_PRIOR . . . . . . . . . . . .	Number	 00000021h   
VK_RBUTTON . . . . . . . . . . .	Number	 00000002h   
VK_RCONTROL  . . . . . . . . . .	Number	 000000A3h   
VK_RETURN  . . . . . . . . . . .	Number	 0000000Dh   
VK_RIGHT . . . . . . . . . . . .	Number	 00000027h   
VK_RMENU . . . . . . . . . . . .	Number	 000000A5h   
VK_RSHIFT  . . . . . . . . . . .	Number	 000000A1h   
VK_SCROLL  . . . . . . . . . . .	Number	 00000091h   
VK_SEPARATER . . . . . . . . . .	Number	 0000006Ch   
VK_SHIFT . . . . . . . . . . . .	Number	 00000010h   
VK_SNAPSHOT  . . . . . . . . . .	Number	 0000002Ch   
VK_SPACE . . . . . . . . . . . .	Number	 00000020h   
VK_SUBTRACT  . . . . . . . . . .	Number	 0000006Dh   
VK_TAB . . . . . . . . . . . . .	Number	 00000009h   
VK_UP  . . . . . . . . . . . . .	Number	 00000026h   
WINDOW_BUFFER_SIZE_EVENT . . . .	Number	 00000004h   
WriteConsoleOutputCharacter  . .	Text   	 WriteConsoleOutputCharacterA
WriteConsole . . . . . . . . . .	Text   	 WriteConsoleA
arrLength  . . . . . . . . . . .	DWord	 000000BA _DATA	
arrMean  . . . . . . . . . . . .	DWord	 00000417 _DATA	
arrMedian  . . . . . . . . . . .	DWord	 00000413 _DATA	
authName . . . . . . . . . . . .	Byte	 00000013 _DATA	
black  . . . . . . . . . . . . .	Number	 00000000h   
blue . . . . . . . . . . . . . .	Number	 00000001h   
brown  . . . . . . . . . . . . .	Number	 00000006h   
cyan . . . . . . . . . . . . . .	Number	 00000003h   
delimiter  . . . . . . . . . . .	Byte	 000000F0 _DATA	
dhline . . . . . . . . . . . . .	Byte	 00000042 _DATA	
exit . . . . . . . . . . . . . .	Text   	 INVOKE ExitProcess,0
gray . . . . . . . . . . . . . .	Number	 00000008h   
green  . . . . . . . . . . . . .	Number	 00000002h   
hline  . . . . . . . . . . . . .	Byte	 00000023 _DATA	
lightBlue  . . . . . . . . . . .	Number	 00000009h   
lightCyan  . . . . . . . . . . .	Number	 0000000Bh   
lightGray  . . . . . . . . . . .	Number	 00000007h   
lightGreen . . . . . . . . . . .	Number	 0000000Ah   
lightMagenta . . . . . . . . . .	Number	 0000000Dh   
lightRed . . . . . . . . . . . .	Number	 0000000Ch   
list . . . . . . . . . . . . . .	DWord	 000000F3 _DATA	
magenta  . . . . . . . . . . . .	Number	 00000005h   
progName . . . . . . . . . . . .	Byte	 00000000 _DATA	
prompt1  . . . . . . . . . . . .	Byte	 00000061 _DATA	
prompt2  . . . . . . . . . . . .	Byte	 00000081 _DATA	
prompt3  . . . . . . . . . . . .	Byte	 00000085 _DATA	
red  . . . . . . . . . . . . . .	Number	 00000004h   
sortHead . . . . . . . . . . . .	Byte	 000000D8 _DATA	
tooHi  . . . . . . . . . . . . .	Byte	 00000089 _DATA	
tooLo  . . . . . . . . . . . . .	Byte	 000000A2 _DATA	
unsortHead . . . . . . . . . . .	Byte	 000000BE _DATA	
white  . . . . . . . . . . . . .	Number	 0000000Fh   
wsprintf . . . . . . . . . . . .	Text   	 wsprintfA
yellow . . . . . . . . . . . . .	Number	 0000000Eh   

	   0 Warnings
	   0 Errors
